package org.improving.scalify

trait Tokens
{
    val NL = Emit("\n")
    val LBRACKET = Emit("[")
    val RBRACKET = Emit("]")
    val LBRACE = Emit("{")
    val RBRACE = Emit("}")
    val LPAREN = Emit("(")
    val RPAREN = Emit(")")
    val EMPTYBRACES = Emit("{ }")
    val ARROWLEFT = Emit("<-")
    val ARROWRIGHT = Emit("->")
    val BOUNDUPPER = Emit("<:")
    val BOUNDLOWER = Emit(">:")
    val COLON = Emit(":")
    val COMMA = Emit(",")
    val COMPLEMENT = Emit("~")
    val DOT = Emit(".")
    val EQUALS = Emit("=")
    val FUNARROW = Emit("=>")
    val ISEQUALTO = Emit("==")
    val ISEQUALTOREF = Emit("eq")
    val LOGICALAND = Emit("&&")
    val LOGICALOR = Emit("||")
    val MINUS = Emit("-")
    val MINUSEQUALS = Emit("-=")
    val NOT = Emit("!")
    val PIPE = Emit("|")
    val PLUS = Emit("+")
    val PLUSEQUALS = Emit("+=")
    val QUOTE = Emit("\"")
    val SEMICOLON = Emit(";")
    val UNDERSCORE = Emit("_")
    val ABSTRACT = Emit("abstract")
    val APPLY = Emit("apply")
    val ASINSTANCEOF = Emit("asInstanceOf")
    val ASSERT = Emit("assert")
    val BOOLEAN = Emit("Boolean")
    val BYTE = Emit("Byte")
    val CASE = Emit("case")
    val CATCH = Emit("catch")
    val CHAR = Emit("Char")
    val CHARACTER = Emit("Character")
    val CLASS = Emit("class")
    val CLASSOF = Emit("classOf")
    val DEF = Emit("def")
    val DO = Emit("do")
    val DOUBLE = Emit("Double")
    val ELSE = Emit("else")
    val EXTENDS = Emit("extends")
    val FALSE = Emit("false")
    val FINAL = Emit("final")
    val FINALLY = Emit("finally")
    val FLOAT = Emit("Float")
    val FOR = Emit("for")
    val IF = Emit("if")
    val IMPORT = Emit("import")
    val INT = Emit("Int")
    val INTEGER = Emit("Integer")
    val ISINSTANCEOF = Emit("isInstanceOf")
    val LONG = Emit("Long")
    val MATCH = Emit("match")
    val NEW = Emit("new")
    val NATIVE = Emit("@native")
    val NULL = Emit("null")
    val OBJECT = Emit("object")
    val OVERRIDE = Emit("override")
    val PACKAGE = Emit("package")
    val PRIVATE = Emit("private")
    val PROTECTED = Emit("protected")
    val RETURN = Emit("return")
    val SHORT = Emit("Short")
    val SUPER = Emit("super")
    val SYNCHRONIZED = Emit("synchronized")
    val THIS = Emit("this")
    val THROW = Emit("throw")
    val TRAIT = Emit("trait")
    val TRANSIENT = Emit("@transient")
    val TRUE = Emit("true")
    val TRY = Emit("try")
    val VAL = Emit("val")
    val VAR = Emit("var")
    val VOLATILE = Emit("@volatile")
    val WHILE = Emit("while")
    val WITH = Emit("with")
    val YIELD = Emit("yield")
    val ANY = Emit("Any")
    val ANYREF = Emit("AnyRef")
    val ARRAY = Emit("Array")
    val BY = Emit("by")
    val ENUMCLASS = Emit("scala.Enumeration")
    val GETORELSE = Emit("getOrElse")
    val INTERNALRETURN = Emit("InternalReturnException")
    val JAVALANG = Emit("java.lang")
    val LPARENDOUBLE = Emit("((")
    val MINUSONE = Emit("-1")
    val NONE = Emit("None")
    val ONE = Emit("1")
    val OPTION = Emit("Option")
    val PRODUCT = Emit("Product")
    val RPARENDOUBLE = Emit("))")
    val ROOTPKG = Emit("_root_")
    val SOME = Emit("Some")
    val TO = Emit("to")
    val TUPLE1 = Emit("Tuple1")
    val UNIT = Emit("Unit")
    val UNTIL = Emit("until")
    val VALUE = Emit("Value")
    val VALUEOF = Emit("valueOf")
    val X = Emit("x")
    val ZERO = Emit("0")
    val BREAK = Emit("Break")
    val CONTINUE = Emit("Continue")
    val LBREAK = Emit("LabeledBreak")
    val LCONTINUE = Emit("LabeledContinue")
    val RETCLASS = Emit("ReturnBox")
    val RETVAL = Emit("Return")
    val SETEQ = Emit("seteq")
    val SETEQLHS = Emit("seteqlhs")
    val UPDATEFUN = Emit("update")
}

